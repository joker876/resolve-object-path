"use strict";Object.defineProperty(exports,"__esModule",{value:true});const _PATH_NEXT_STEPS_REGEXP=/((?:\??\.|(?:\?\.)?\[).*$|$)/.source;const _STRING_PROP_REGEXP=new RegExp(/^([\w$]+)/.source+_PATH_NEXT_STEPS_REGEXP);const _ARRAY_PROP_REGEXP=new RegExp(/^\[(?:(-?\d+(?:\.\d+)?)|(['"`])(.*?)\2)\](?=\??\.|\[(?:(?:-?\d+(?:\.\d+)?)|(['"`]).*?\4)|$)/.source+_PATH_NEXT_STEPS_REGEXP);function resolvePath(object,path){if(typeof object!="object")throw new TypeError("Expected object argument to be an object, got "+typeof object);if(typeof path!="string")throw new TypeError("Expected path argument to be a string, got "+typeof path);return _processPathRecursive(object,path)}function _processPathRecursive(object,path,originalPath=path){if(!path)return object;let step;[step,path]=_getPathStep(path,originalPath);if(object.hasOwnProperty(step)){return _processPathRecursive(object[step],path,originalPath)}return undefined}function _getPathStep(path,originalPath){let step;let newPath;let match=path.match(_STRING_PROP_REGEXP);if(match){step=match[1];newPath=_removeChainOperator(match[2]);return[step,newPath]}match=path.match(_ARRAY_PROP_REGEXP);if(match){step=match[1]?_convertStepToNumberIfNeeded(match[1]):match[3];newPath=_removeChainOperator(match[5]);return[step,newPath]}throw new Error("Object path is invalid: "+originalPath)}function _removeChainOperator(step){if(step.charAt(0)==".")return step.slice(1);if(step.charAt(0)=="?")return step.slice(2);return step}function _convertStepToNumberIfNeeded(step){if(!isNaN(Number(step))){return Number(step)}return step}exports.default=resolvePath;